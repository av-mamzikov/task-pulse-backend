# DDD Implementation Guide

## Overview

This document describes the Domain-Driven Design (DDD) implementation in the TaskPulse backend application. The implementation follows tactical DDD patterns including Aggregates, Domain Events, Specifications, and Domain Services.

## Architecture Layers

### 1. Domain Layer (`src/core/domain/`)

The domain layer contains all business logic and is independent of infrastructure concerns.

#### Aggregates (`aggregates/`)

**Task Aggregate Root**

- Entry point to the Task aggregate
- Manages Task and Comment entities as a single unit
- Enforces business rules and invariants
- Generates domain events for all state changes

```typescript
// Creating a new task
const task = Task.create(
    new TaskTitle('Implement DDD'),
    Priority.High,
    new DueDate(new Date('2025-12-31'))
);

// Changing status (with validation)
task.changeStatus(TaskStatus.InProgress); // ✓ Valid transition
task.changeStatus(TaskStatus.Done);       // ✗ Throws InvalidStatusTransitionException

// Adding a comment
const comment = task.addComment(new CommentText('Great progress!'));
```

**Comment Entity**

- Part of the Task aggregate (not an aggregate root)
- Can only be created and modified through Task
- Cannot exist independently

#### Domain Events (`events/`)

Events represent things that happened in the domain:

- `TaskCreated` - When a new task is created
- `TaskStatusChanged` - When task status changes
- `TaskPriorityChanged` - When task priority changes
- `TaskCompleted` - When a task is marked as done
- `TaskDeleted` - When a task is deleted
- `TaskDueDateChanged` - When due date changes
- `TaskTitleChanged` - When title changes
- `TaskDescriptionChanged` - When description changes
- `CommentAdded` - When a comment is added
- `CommentDeleted` - When a comment is removed

Events are:

1. Generated by aggregate methods
2. Stored in the aggregate until persistence
3. Dispatched after successful database commit
4. Handled by event handlers for side effects

#### Specifications (`specifications/`)

Encapsulate business rules for querying:

```typescript
// Find overdue high-priority tasks
const overdueSpec = new OverdueTasksSpecification();
const highPrioritySpec = new HighPriorityTasksSpecification();

const criticalTasks = await taskRepository.findBySpecification(
    overdueSpec.and(highPrioritySpec)
);
```

Available specifications:

- `OverdueTasksSpecification` - Tasks past due date
- `HighPriorityTasksSpecification` - High priority tasks
- `CompletableTaskSpecification` - Tasks that can be completed
- `ActiveTasksSpecification` - Non-completed tasks

#### Domain Services (`services/`)

**TaskPriorityService**

- Escalates priority for overdue tasks
- Calculates dynamic priority based on due date and workload
- Rebalances priorities across multiple tasks

**TaskValidationService**

- Validates status transitions
- Checks if tasks can be deleted
- Validates task state

#### Exceptions (`exceptions/`)

Domain-specific exceptions for business rule violations:

- `DomainException` - Base exception
- `InvalidStatusTransitionException` - Invalid status change
- `TaskNotFoundException` - Task not found
- `InvalidDueDateException` - Invalid due date
- `CommentNotFoundException` - Comment not found

#### Value Objects (`value-objects/`)

Immutable objects representing domain concepts:

- `TaskTitle` - Task title with validation
- `TaskDescription` - Task description
- `DueDate` - Due date with business logic
- `CommentText` - Comment text with validation

### 2. Application Layer (`src/core/application/`)

Orchestrates domain objects and coordinates application workflows.

#### Result Pattern (`common/Result.ts`)

Type-safe error handling without exceptions:

```typescript
const result = await useCase.execute(taskId, newStatus);

if (result.isSuccess) {
    console.log('Task updated:', result.value);
} else {
    console.error('Error:', result.error);
}
```

#### Repository Interfaces (`interfaces/`)

Define contracts for data access:

```typescript
interface ITaskRepository {
    create(task: Task): Promise<Task>;

    findById(id: string): Promise<Task | null>;

    findByIdWithComments(id: string): Promise<Task | null>;

    findAll(filters?: TaskFilterOptions): Promise<Task[]>;

    findBySpecification(spec: Specification<Task>): Promise<Task[]>;

    update(task: Task): Promise<Task>;

    delete(id: string): Promise<boolean>;
}
```

### 3. Infrastructure Layer (`src/infrastructure/`)

Provides technical implementations.

#### Event Dispatcher (`events/EventDispatcher.ts`)

Manages event registration and dispatching:

```typescript
// Registration (in DI container)
eventDispatcher.register('TaskCreated', new TaskCreatedHandler());

// Dispatching (automatic in repository)
await eventDispatcher.dispatch(event);
```

#### Event Handlers (`events/handlers/`)

Handle side effects of domain events:

- Logging
- Notifications (future)
- Analytics (future)
- Webhooks (future)

#### Repository Implementation (`repositories/TaskRepository.ts`)

TypeORM implementation with:

- Aggregate persistence (task + comments)
- Transaction management
- Event dispatching after commit
- Specification support

```typescript
async
create(task
:
Task
):
Promise < Task > {
    // Start transaction
    // Save task entity
    // Save comment entities
    // Commit transaction
    // Dispatch domain events
    // Return reconstituted aggregate
}
```

#### Mappers (`database/mappers/`)

Convert between domain and persistence models:

```typescript
// Domain → Persistence
const entity = TaskMapper.toPersistence(task);

// Persistence → Domain
const task = TaskMapper.toDomain(entity, commentEntities);
```

## Business Rules

### Task Status Transitions

Valid transitions:

- `New` → `InProgress` ✓
- `InProgress` → `Done` ✓
- `Done` → `InProgress` ✓ (reopen)

Invalid transitions:

- `New` → `Done` ✗ (must go through InProgress)

### Task Lifecycle

1. **Creation**
    - Must have title, priority, and due date
    - Starts in `New` status
    - Generates `TaskCreated` event

2. **Status Changes**
    - Validated by business rules
    - Generates `TaskStatusChanged` event
    - Completing generates additional `TaskCompleted` event

3. **Priority Changes**
    - Can be changed at any time
    - Generates `TaskPriorityChanged` event
    - Can be auto-escalated for overdue tasks

4. **Comments**
    - Can be added to any task
    - Generates `CommentAdded` event
    - Deletion generates `CommentDeleted` event

5. **Deletion**
    - Validates deletion is allowed
    - Cascades to comments
    - Generates `TaskDeleted` event

## Usage Examples

### Creating a Task

```typescript
import {Task, TaskTitle, Priority, DueDate} from '@core/domain';

const task = Task.create(
    new TaskTitle('Implement feature X'),
    Priority.High,
    new DueDate(new Date('2025-12-31')),
    new TaskDescription('Detailed description')
);

await taskRepository.create(task);
// → TaskCreated event dispatched
// → Handler logs creation
```

### Updating Task Status

```typescript
const task = await taskRepository.findById(taskId);

if (!task) {
    return Result.fail('Task not found');
}

try {
    task.changeStatus(TaskStatus.InProgress);
    await taskRepository.update(task);
    // → TaskStatusChanged event dispatched
    return Result.ok(task);
} catch (error) {
    if (error instanceof InvalidStatusTransitionException) {
        return Result.fail(error.message);
    }
    throw error;
}
```

### Adding a Comment

```typescript
const task = await taskRepository.findByIdWithComments(taskId);

const comment = task.addComment(new CommentText('This is a comment'));
await taskRepository.update(task);
// → CommentAdded event dispatched
```

### Using Specifications

```typescript
import {
    OverdueTasksSpecification,
    HighPriorityTasksSpecification
} from '@core/domain';

// Find critical tasks
const criticalSpec = new OverdueTasksSpecification()
    .and(new HighPriorityTasksSpecification());

const criticalTasks = await taskRepository.findBySpecification(criticalSpec);
```

### Using Domain Services

```typescript
import {TaskPriorityService} from '@core/domain';

const priorityService = new TaskPriorityService();

// Escalate overdue tasks
const allTasks = await taskRepository.findAll();
const escalatedTasks = priorityService.escalatePriorityForOverdueTasks(allTasks);

// Save escalated tasks
for (const task of escalatedTasks) {
  await taskRepository.update(task);
  // → TaskPriorityChanged events dispatched
}
```

## Event Flow

```
1. User Action (e.g., change status)
   ↓
2. Controller calls Use Case
   ↓
3. Use Case loads aggregate from repository
   ↓
4. Aggregate method called (e.g., task.changeStatus())
   ↓
5. Business rules validated
   ↓
6. State changed
   ↓
7. Domain event added to aggregate
   ↓
8. Repository saves aggregate
   ↓
9. Database transaction committed
   ↓
10. Events dispatched to handlers
    ↓
11. Handlers perform side effects (logging, notifications, etc.)
    ↓
12. Events cleared from aggregate
```

## Testing Strategy

### Unit Tests

Test domain logic in isolation:

```typescript
describe('Task Aggregate', () => {
    it('should not allow direct transition from New to Done', () => {
        const task = Task.create(title, priority, dueDate);

        expect(() => task.changeStatus(TaskStatus.Done))
            .toThrow(InvalidStatusTransitionException);
    });
});
```

### Integration Tests

Test with real database and events:

```typescript
describe('TaskRepository', () => {
    it('should dispatch events after creating task', async () => {
        const task = Task.create(title, priority, dueDate);
        const eventSpy = jest.spyOn(eventDispatcher, 'dispatch');

        await repository.create(task);

        expect(eventSpy).toHaveBeenCalledWith(
            expect.objectContaining({eventName: 'TaskCreated'})
        );
    });
});
```

## Migration from Legacy Code

The implementation maintains backward compatibility:

```typescript
// Old entities still exported as legacy
import {TaskLegacy, CommentLegacy} from '@core/domain';

// New aggregates are the default
import {Task, Comment} from '@core/domain';
```

Gradually migrate code to use new aggregates and remove legacy exports when ready.

## Future Enhancements

1. **Event Sourcing** - Store all events for complete audit trail
2. **CQRS** - Separate read and write models
3. **Sagas** - Complex multi-step business processes
4. **Bounded Contexts** - Separate domains as application grows
5. **Integration Events** - Communicate with external systems
6. **Unit of Work** - More sophisticated transaction management

## References

- [Domain-Driven Design by Eric Evans](https://www.domainlanguage.com/ddd/)
- [Implementing Domain-Driven Design by Vaughn Vernon](https://vaughnvernon.com/)
- [DDD Reference](https://www.domainlanguage.com/ddd/reference/)

---

**Last Updated:** 2025-11-10
**Version:** 1.0
